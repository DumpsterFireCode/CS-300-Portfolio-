# CS-300-Portfolio-


    What was the problem you were solving in the projects for this course?
    
In this course, we were creating a sorting algorithm for a program that would print out a class schedule sorted using our method of choice. In my case, I created a binary search tree. 

    How did you approach the problem? Consider why data structures are important to understand.
    
We firstly created pseudocode for what we have to create, this is to ensure we understand each step that needs to happen to correctly build a BST. If we are creating a BST, we need a slightly different node structure rather than what we would need if we were creating a hash table. We would potentially also need a linked list in a hash table if we are to handle colisions. 

    How did you overcome any roadblocks you encountered while going through the activities or project?
    
Quite frankly this was one of the most frustrating projects I've ever worked on. I initially created a hash table, however I did not realize the data we are working with does not have a unique ID that is sortable, unlike previous datasets that had a unique ID that we could easily use. This made creating a hash based on the number relatively difficult which I decided was easier to solve by switching to a completely different data structure, a BST. Sorting a mixed number and letter identifer in a BST was much easier at the time I was programming this, so I decided that was the way I wanted to go. While the data structure itself was more difficult to implement, it was less difficult to get working correctly, which ended up saving time and being a little less stressful.

    How has your work on this project expanded your approach to designing software and developing programs?
    
  I learned quite a bit this semester, particularly in planning out and getting my algorithms dialed in correctly prior to actually programming anything. This ensured my code was relatively concise and skipped needless steps that I may have added due to a lack of prior planning if I had just jumped into it.
  
    How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

As always, we used OOP principles in this project which ensured that my code was modular, maintainable and relatively easy to understand from reading. Abstraction and encapsulation were two priciples that I feel received special attention in this project through the modular functions that each did their respective job. As well as all of the classes built with correct accessor and mutator methods. 
